#!/usr/bin/expect
############################################################################
# Purpose: Establish global state information for SLURM test suite
############################################################################
# Copyright (C) 2002-2006 The Regents of the University of California.
# Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
# Written by Morris Jette <jette1@llnl.gov>
# UCRL-CODE-217948.
# 
# This file is part of SLURM, a resource management program.
# For details, see <http://www.llnl.gov/linux/slurm/>.
#  
# SLURM is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
# 
# SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License along
# with SLURM; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.
############################################################################

global sacct sbcast scancel scontrol sinfo smap squeue srun

#
# Specify the slurm install directory.
# Used to locate binaries, libraries, and header files.
#
set slurm_dir   "/usr"
set sacct       "${slurm_dir}/bin/sacct"
set sbcast      "${slurm_dir}/bin/sbcast"
set scancel     "${slurm_dir}/bin/scancel"
set scontrol    "${slurm_dir}/bin/scontrol"
set sinfo       "${slurm_dir}/bin/sinfo"
set smap        "${slurm_dir}/bin/smap"
set squeue      "${slurm_dir}/bin/squeue"
set srun        "${slurm_dir}/bin/srun"

# If using MPICH-2 or other version of MPI requiring pmi libary, use this
#set mpicc	"/home/jette/mpich2-install/bin/mpicc"
#set use_pmi	1
# OR for other versions of MPICH, use this
set mpicc       "/usr/local/bin/mpicc"
set use_pmi	0

# If using XCPU job launch, specify directory location as needed
set xcpu_dir	"/mnt/xcpu"

set poe		"/usr/bin/poe"
set mpirun	"mpirun"
set totalviewcli	"/usr/local/bin/totalviewcli"

# Pattern to match your shell prompt
set prompt "(%|#|\\\$) $"

#
# Specify locations of other executable files used
# Only the shell names (e.g. bin_bash) must be full pathnames
#
set bin_awk 	"awk"
set bin_bash	"/bin/bash"
set bin_cat	"cat"
set bin_cc	"gcc"
set bin_chmod	"chmod"
set bin_cp	"cp"
set bin_diff	"diff"
set bin_echo	"echo"
set bin_env	"env"
set bin_file	"file"
set bin_id	"id"
set bin_grep    "grep"
set bin_hostname "hostname"
set bin_kill	"kill"
set bin_make	"make"
set bin_pkill	"pkill"
set bin_ps	"ps"
set bin_pwd	"pwd"
set bin_rm	"rm"
set bin_sleep   "sleep"
set bin_sort    "sort"
set bin_touch   "touch"
set bin_uname	"uname"
set bin_usleep  "usleep"
set bin_wc	"wc"

#
# Let the commands complete without expect timing out waiting for a 
# response. Single node jobs submitted to the default partition should 
# be initiated within this number of seconds.
# for interactive slurm jobs: set timeout $max_job_delay
#
set max_job_delay 120

#
# Files must be propogated between nodes within this number of seconds.
# The delay may be due to NFS.
#
set max_file_delay 60

#
# Specify the maximum number of tasks to use in the stress tests.
#
set max_stress_tasks 4

# Other common variables
set alpha                "\[a-zA-Z\]+"
set alpha_cap            "\[A-Z\]+"
set alpha_numeric        "\[a-zA-Z0-9\]+"
set alpha_numeric_under  "\[a-zA-Z0-9_\]+"
set alpha_under          "\[A-Z_\]+"
set end_of_line          "\[\r\n\]"
set number               "\[0-9\]+"

#
# Cache SlurmUser to check for SuperUser requests
#
set super_user     0
set super_user_set 0

################################################################
#
# Proc: cancel_job
#
# Purpose:  Cancel the specified job
#
# Returns: A non-zero return code indicates a failure.
#
# Input: job_id  -- The SLURM job id of a job we want to cancel.
#
################################################################

proc cancel_job { job_id } {
	global scancel bin_sleep

	send_user "cancelling $job_id\n"
	exec $scancel -q $job_id
	exec $bin_sleep 1
	return [wait_for_job $job_id "DONE"]
}


################################################################
#
# Proc: get_line_cnt
#
# Purpose:  Return size of the specified file
#
# Returns: Number of lines in the specified file.
#
# Input: file_name  -- Name of file to inspect.
#
################################################################
proc get_line_cnt { file_name } {
	global bin_wc number
	set lines 0
	spawn $bin_wc -l $file_name
	expect {
		-re "($number) " {
			set lines $expect_out(1,string)
			exp_continue
		}
		eof {
			wait
		}
	}
	return $lines
}

################################################################
#
# Proc: kill_srun
#
# Purpose:  Kill all srun commands associated with this user.
#	Issue two SIGINT, sleep 1 and a SIGKILL
#
# Returns: A non-zero return code indicates a failure.
#
# Note: usleep is used to avoid pkill race error message (the
# processes terminate after the process table is read and before
# the signal is sent to the detected processses)
#
################################################################

proc kill_srun {  } {
	global bin_id bin_pkill bin_sleep bin_usleep number

	spawn $bin_id -u
	expect {
		-re "($number)" {
			set uid $expect_out(1,string)
			exp_continue
		}
		eof {
			wait
		}
	}

	spawn $bin_pkill -INT -u $uid srun
	expect {
		eof {
			wait
		}
	}
	exec $bin_usleep 1000
	spawn $bin_pkill -INT -u $uid srun
	expect {
		eof {
			wait
		}
	}
	exec $bin_sleep  1
	spawn $bin_pkill -KILL -u $uid srun
	expect {
		eof {
			wait
		}
	}

	return 0
}


################################################################
#
# Proc: print_header
#
# Purpose:  Print header with test ID
#
# Input: job_id   -- The SLURM job id of a job we want to cancel.
#
################################################################

proc print_header { test_id } {

	send_user "============================================\n"
	send_user "TEST: $test_id\n"
}


################################################################
#
# Proc: wait_for_file
#
# Purpose:  Wait for the specified file to exist. This delay 
# provides time for NFS files to be propogated. The 
#
# Returns: A non-zero return code indicates a failure.
#
# Input: file_name   -- Name of the file to wait for.
#
################################################################

proc wait_for_file { file_name } {
	global bin_sleep max_file_delay

	for {set my_delay 0} {$my_delay <= $max_file_delay} {incr my_delay} {
		if {$my_delay > 0} {
			exec $bin_sleep 1
		}
		if [file exists $file_name] {
			return 0
		}
	}
	send_user "\nFAILURE: Timeout waiting for file $file_name\n"
	return 1
}


################################################################
#
# Proc: wait_for_job
#
# Purpose:  Wait for a previously submitted SLURM job to reach 
# the desired state, exponential back-off 1 to 10 seconds
#
# Returns: A non-zero return code indicates a failure.
#
# Input: job_id   -- The SLURM job id of a job we want to
#                    wait for.
#        state    -- The state you want the job to attain before
#                    returning.  Currently supports:
#                        DONE any terminated state
#                        RUNNING job is running
#
# NOTE: We sleep for two seconds before replying that a job is 
# done to give time for I/O completion (stdout/stderr files)
#
################################################################

proc wait_for_job { job_id state } {
	global bin_sleep max_job_delay
	global scontrol
	set is_done     0
	set is_running  0
	set sleep_time  1

	log_user 0
	while { 1 == 1 } {
		spawn -noecho $scontrol -o show job $job_id
		expect {
			-re "Job \[0-9]* not found" {
				set is_done 1 
				exp_continue
			}
			-re "JobState=CANCELLED" {
				set is_done 1 
				exp_continue
			}
			-re "JobState=COMPLETE" {
				set is_done 1 
				exp_continue
			}
			-re "JobState=FAILED" {
				set is_done 1 
				exp_continue
			}
			-re "JobState=TIMEOUT" {
				set is_done 1 
				exp_continue
			}
			-re "JobState=NODE_FAIL" {
				set is_done 1 
				exp_continue
			}
			-re "JobState=RUNNING" {
				set is_running 1 
				exp_continue
			}
			timeout {
				send_user "\nFAILURE: scontrol not responding\n"
				log_user 1
				return 1
			}
			eof {
				wait
			}
		}
		log_user 1
	
		if {[string compare $state "DONE"] == 0    && $is_done == 1 } {
			exec $bin_sleep  2
			return 0
		}
		if {[string compare $state "RUNNING"] == 0 && $is_running == 1 } {
			return 0
		}
		if {                                          $is_done == 1 } {
			return 1
		}

		exec $bin_sleep $sleep_time
		set sleep_time  [expr $sleep_time * 2]
		if { $sleep_time > 10 } {
			set sleep_time 10
		}
	}
}

################################################################
#
# Proc: test_front_end
#
# Purpose: Determine if the execution host is one in which the
# slurmd daemon executes on a front-end node rather than the 
# compute hosts (e.g. Blue Gene systems). This is based upon 
# the value of SelectType in the slurm.conf.
#
# Returns 1 if the system uses a front-end, 0 otherwise
#
################################################################

proc test_front_end { } {
	global scontrol bin_bash bin_grep xcpu_dir

	if [file exists $xcpu_dir] {
		return 1
	}

	log_user 0
	set bluegene 0
	spawn -noecho $bin_bash -c "exec $scontrol show config | $bin_grep SelectType"
	expect {
		"select/bluegene" {
			set bluegene 1
			exp_continue
		}
		eof {
			wait
		}
	}
	log_user 1
	
	return $bluegene
}

################################################################
#
# Proc: test_xcpu
#
# Purpose: Determine if the system xcpu for task launch
#
# Returns 1 if the system is xcpu, 0 otherwise
#
################################################################

proc test_xcpu { } {
	global xcpu_dir

	if [file exists $xcpu_dir] {
		return 1
	}

	return 0
}

################################################################
#
# Proc: test_bluegene
#
# Purpose: Determine if the system is a bluegene system
#
# Returns 1 if the system is a bluegene, 0 otherwise
#
################################################################

proc test_bluegene { } {
	global scontrol bin_bash bin_grep

	log_user 0
	set bluegene 0
	spawn -noecho $bin_bash -c "exec $scontrol show config | $bin_grep SelectType"
	expect {
		"select/bluegene" {
			set bluegene 1
			exp_continue
		}
		eof {
			wait
		}
	}
	log_user 1
	
	return $bluegene
}

################################################################
#
# Proc: test_super_user
#
# Purpose: Determine if user is a SLURM super user (i.e. user 
# root or configured SlurmUser)
#
################################################################

proc test_super_user { } {
	global alpha_numeric bin_id number scontrol super_user super_user_set

	if {$super_user_set != 0} {
		return $super_user
	}

#
#	Check if user root
#
	log_user 0
	spawn $bin_id -u
	set uid -1
	expect {
		-re "($number)" {
			set uid $expect_out(1,string)
			exp_continue
		}
		eof {
			wait
		}
	}
	if {$uid == 0} {
		log_user 1
		set super_user 1
		set super_user_set 1
		return $super_user
	}

#
#	Check if SlurmUser
#
	spawn $bin_id -un
	set user ""
	expect {
		-re "($alpha_numeric)" {
			set user $expect_out(1,string)
			exp_continue
		}
		eof {
			wait
		}
	}
	spawn $scontrol show control
	set slurm_user ""
	expect {
		-re "SlurmUser *= ($alpha_numeric)" {
			set slurm_user $expect_out(1,string)
			exp_continue
		}
		eof {
			wait
		}
	}
	if {[string compare $user $slurm_user] == 0} {
		set super_user 1
	}
	set super_user_set 1
	log_user 1
	return $super_user
}

# Create a 16 bit hex number from a signed decimal number
# Replace all non-decimal characters
# Courtesy of Chris Cornish
# http://aspn.activestate.com/ASPN/Cookbook/Tcl/Recipe/415982
proc dec2hex16 {value} {
	regsub -all {[^0-x\.-]} $value {} newtemp
	set value [string trim $newtemp]
	if {$value < 32767 && $value > -32768} {
		set tempvalue [format "%#010X" [expr $value]]
		return [string range $tempvalue 6 9]
	} elseif {$value < 32768} {
		return "8000"
	} else {
		return "7FFF"
	}
}

