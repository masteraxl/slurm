.TH "Slurm API" "3" "March 2005" "Morris Jette" "Slurm task spawn functions"
.SH "NAME"
slurm_spawn \- Slurm task spawn functions
.SH "SYNTAX"
.LP 
#include <slurm/slurm.h>
.LP 
.LP
slurm_step_ctx \fBslurm_step_ctx_create\fR (
.br
	job_step_create_request_msg_t *\fIstep_req\fP 
.br
);
.LP
int \fBslurm_step_ctx_get\fR (
.br
	slurm_step_ctx \fIctx\fP,
.br
	int \fIctx_key\fP,
.br
	...
.br
);
.LP
int \fBslurm_jobinfo_ctx_get\fR (
.br
	switch_jobinfo_t \fIjobinfo\fP, 
.br
	int \fIdata_type\fP, 
.br
	void *\fIdata\fP
.br
);
.LP
int \fBslurm_step_ctx_set\fR (
.br
	slurm_step_ctx \fIctx\fP,
.br
	int \fIctx_key\fP,
.br
	...
.br
);
.LP
int \fBslurm_spawn\fR {
.br
	slurm_step_ctx \fIctx\fP,
.br
	int *\fIfd_array\fP
.br
);
.LP
int \fBslurm_spawn_kill\fR {
.br
        slurm_step_ctx \fIctx\fP,
.br
	uint16_t \fIsignal\fP
.br
);
.LP
int \fBslurm_step_ctx_destroy\fR {
.br
	slurm_step_ctx \fIctx\fP
.br
);
.SH "ARGUMENTS"
.LP 
.TP
\fIstep_req\fP
Specifies the pointer to the structure with job step request specification. See 
slurm.h for full details on the data structure's contents.
.TP
\fIctx\fP
Job step context. Created by \fBslurm_step_ctx_create\fR, used in subsequent
function calls, and destroyed by \fBslurm_step_ctx_destroy\fR.
.TP
\fIctx_key\fP
Identifies the fields in \fIctx\fP to be collected by \fBslurm_step_ctx_get\fR
or set by \fBslurm_step_ctx_set\fR.
.TP
\fIdata\fP
Storage location for requested data. See \fIdata_type\fP below.
.TP
\fIdata_type\fP
Switch-specific data requested. The interpretation of this field depends
upon the switch plugin in use.
.TP
\fIfd_array\fP
Array of socket file descriptors to be connected to the initiated tasks.
Tasks will be connected to these file descriptors in order of their 
task id.
This socket will carry standard input, output and error for the task.
\fIjobinfo\fP
Switch-specific job information as returned by \fBslurm_step_ctx_get\fR.
.TP
\fIsignal\fP
Signal to be sent to the spawned tasks. 
.SH "DESCRIPTION"
.LP
\fBslurm_jobinfo_ctx_get\fR Get values from a \fIjobinfo\fR field as
returned by \fBslurm_step_ctx_get\fR. The operation of this function 
is highly dependent upon the switch plugin in use.
.LP
\fBslurm_step_ctx_create\fR Create a job step context. To avoid memory 
leaks call \fBslurm_step_ctx_destroy\fR when the use of this context is
finished. NOTE: this function creates a slurm job step. Call \fBslurm_spawn\fR 
in a timely fashion to avoid having job step credentials time out. If
\fBslurm_spawn\fR is not used, explicitly cancel the job step. 
.LP
\fBslurm_step_ctx_get\fR Get values from a job step context.
\fIctx_key\fP identifies the fields to be gathered from the job step context.
Subsequent arguments to this function are dependent upon the value
of \fIctx_key\fP. See the \fBCONTEXT KEYS\fR section for details.
.LP
\fBslurm_step_ctx_set\fR Set values in a job step context.
\fIctx_key\fP identifies the fields to be set in the job step context.
Subsequent arguments to this function are dependent upon the value 
of \fIctx_key\fP. See the \fBCONTEXT KEYS\fR section for details.
.LP
\fBslurm_spawn\fR Spawn tasks based upon a job step context
and establish communications with the tasks using the socket 
file descriptors specified.
Note that this function can only be called once for each job 
step context. 
Establish a new job step context for each set of tasks to be spawned.
.LP
\fBslurm_spawn_kill\fR Signal the tasks spawned for this context 
by \fBslurm_spawn\fR.
.LP
\fBslurm_step_ctx_destroy\fR Destroy a job step context created by
\fBslurm_step_ctx_create\fR. 
.SH "CONEXT KEYS"
.TP
\fBSLURM_STEP_CTX_ARGS\fR
Set the argument count and values for the executable.
Accepts two additional arguments, the first of type int and
the second of type char **.
.TP
\fBSLURM_STEP_CTX_CHDIR\fR
Have the remote process change directory to the specified location 
before beginning execution. Accepts one argument of type
char * indentifying the directory's pathname. By default
the remote process will execute in the same directory pathname
from which it is spawned. NOTE: This assumes that same directory 
pathname exists on the other nodes. 
.TP
\fBSLURM_STEP_CTX_ENV\fR
Sets the environment variable count and values for the executable.
Accepts two additional arguments, the first of type int and
the second of type char **. By default the current environment 
variables are copied to started task's environment.
.TP
\fBSLURM_STEP_CTX_RESP\fR
Get the job step response message.
Accepts one additional argument of type job_step_create_response_msg_t **.
.TP
\fBSLURM_STEP_CTX_STEPID\fR
Get the step id of the created job step.
Accepts one additional argument of type uint32_t *.
.TP
\fBSLURM_STEP_CTX_TASKS\fR
Get the number of tasks per node for a given job.
Accepts one additional argument of type uint32_t **. 
This argument will be set to point to an array with the 
task counts of each node in an element of the array.
See \fBSLURM_STEP_CTX_TID\fR below to determine the 
task ID numbers associated with each of those tasks.
.TP
\fBSLURM_STEP_CTX_TID\fR
Get the task ID numbers associated with the tasks allocated to 
a specific node.
Accepts two additional arguments, the first of type int and
the second of type uint32_t **. The first argument identifies 
the node number of interest (zero origin). The second argument 
will be set to point to an array with the task ID numbers of 
each task allocated to the node (also zero origin). 
See \fBSLURM_STEP_CTX_TASKS\fR above to determine how many 
tasks are associated with each node.
.SH "RETURN VALUE"
.LP
For \fB slurm_step_ctx_create\fR a context is return upon success. On error
NULL is returned and the Slurm error code is set appropriately.
.LP
For all other functions zero is returned upon success. 
On error, -1 is returned, and the Slurm error code is set appropriately.
.SH "ERRORS"
.LP
\fBEINVAL\fR Invalid argument
.LP
\fBSLURM_PROTOCOL_VERSION_ERROR\fR Protocol version has changed, re-link your code.
.LP
\fBESLURM_INVALID_JOB_ID\fR the requested job id does not exist. 
.LP
\fBESLURM_ALREADY_DONE\fR the specified job has already completed and can not be modified. 
.LP
\fBESLURM_ACCESS_DENIED\fR the requesting user lacks authorization for the requested action (e.g. trying to delete or modify another user's job). 
.LP
\fBESLURM_INTERCONNECT_FAILURE\fR failed to configure the node interconnect. 
.LP
\fBESLURM_BAD_DIST\fR task distribution specification is invalid. 
.LP
\fBSLURM_PROTOCOL_SOCKET_IMPL_TIMEOUT\fR Timeout in communicating with 
SLURM controller.
.SH "EXAMPLE
.LP
#include <signal.h>
.br
#include <stdio.h>
.br
#include <stdlib.h>
.br
#include <string.h>
.br
#include <unistd.h>
.br
#include <sys/types.h>
.br
#include <slurm/slurm.h>
.br
#include <slurm/slurm_errno.h>
.LP
static int *_build_socket_array(int nodes);
.br
static void _do_task_work(int *fd_array, int nodes);
.LP 
int main (int argc, char *argv[])
.br 
{
.br
	int i, j, nodes = 1, tasks;
.br
	job_desc_msg_t job_req;
.br
	resource_allocation_response_msg_t *job_resp;
.br
	job_step_create_request_msg_t; step_req;
.br 
	slurm_step_ctx ctx;
.br
	char *task_argv[2];
.br
	int *fd_array;
.br
	uint32_t *task_cnt; *tid;
.LP
	if (argc > 1) {
.br
		i = atoi(argv[1]);
.br
		if (i > 0)
.br
			nodes = i;
.br
	}
.br
	tasks = nodes;
.LP
	/* Create a job allocation */
.br
	slurm_init_job_desc_msg( &job_req );
.br
	job_req.min_nodes = nodes;
.br
	if (slurm_allocate_resources(&job_req, &job_resp)) {
.br
		slurm_perror ("slurm_allocate_resources error");
.br
		exit (1);
.br
	}
.LP
	/* Set up step configuration */
.br
	bzero(&step_req, sizeof(job_step_create_request_msg_t ));
.br
	step_req.job_id = job_resp->job_id;
.br
	step_req.user_id = getuid();
.br
	step_req.node_count = nodes;
.br
	step_req.num_tasks = tasks;
.br
	step_req.num_tasks = nodes;
.br
	ctx = slurm_step_ctx_create(&step_req);
.br
	if (ctx == NULL) {
.br
		slurm_perror("slurm_step_ctx_create");
.br
		exit(1);
.br
	}
.LP
	task_argv[0] = "/bin/hostname";
.br
	if (slurm_step_ctx_set(ctx, SLURM_STEP_CTX_ARGS,
.br
			1, &task_argv))
.br
		slurm_perror("slurm_step_ctx_create");
.br
	fd_array = _build_socket_array(tasks);
.LP
	/* Spawn the tasks */
.br
	if (slurm_spawn(ctx, fd_array)) {
.br
		slurm_perror("slurm_spawn");
.br
		slurm_kill_job(job_resp->job_id, SIGKILL, 0);
.br
		exit(1);
.br
	}
.LP
	printf("Started %d tasks on %d nodes\\n",
.br
		step_req.num_tasks, step_req.node_count);
.br
	if (slurm_step_ctx_get(ctx, SLURM_STEP_CTX_TASKS, &task_cnt)) {
.br
		slurm_perror("slurm_step_ctx_create");
.br
		exit(1);
.br
	}
.br
	for (i=0; i<step_req.node_count; i++) {
.br
		if (slurm_step_ctx_get(ctx, SLURM_STEP_CTX_TID, i, &tid)) {
.br
			slurm_perror("slurm_step_ctx_create");
.br
			exit(1);
.br
		}
.br
		for (j=0; j<task_cnt[i]; j++)
.br
			printf("tid[%d][%d] = %u\\n", i, j, tid[j]);
.br
	
.LP
	/* Interact with spawned tasks as desired */
.br
	_do_task_work(fd_array, tasks);
.LP
	if (slurm_spawn_kill(ctx, SIGKILL))
.br
		slurm_perror("slurm_spawn_kill");
.LP
	/* Terminate the job killing all tasks */
.br
	slurm_kill_job(job_resp->job_id, SIGKILL, 0);
.br
	slurm_step_ctx_destroy(ctx);
.br
	slurm_free_resource_allocation_response_msg(job_resp);
.br
	exit (0);
.br
}

.SH "COPYING"
Copyright (C) 2004 The Regents of the University of California.
Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
UCRL-CODE-217948.
.LP
This file is part of SLURM, a resource management program.
For details, see <http://www.llnl.gov/linux/slurm/>.
.LP
SLURM is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.
.LP
SLURM is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.
.SH "SEE ALSO"
.LP 
\fBslurm_allocate_resources\fR(3), \fBslurm_job_step_create\fR(3), 
\fBslurm_kill_job\fR(3), 
\fBslurm_get_errno\fR(3), \fBslurm_perror\fR(3), \fBslurm_strerror\fR(3),
\fBsrun\fR(1) 
